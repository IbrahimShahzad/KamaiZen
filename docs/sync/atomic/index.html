<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>atomic - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../../lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.18.1";</script>
<script src="../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="../../index.html">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="../../index.html">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:8080/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package atomic
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "sync/atomic"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="index.html#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package atomic provides low-level atomic memory primitives
useful for implementing synchronization algorithms.
</p>
<p>
These functions require great care to be used correctly.
Except for special, low-level applications, synchronization is better
done with channels or the facilities of the [sync] package.
Share memory by communicating;
don&#39;t communicate by sharing memory.
</p>
<p>
The swap operation, implemented by the SwapT functions, is the atomic
equivalent of:
</p>
<pre>old = *addr
*addr = new
return old
</pre>
<p>
The compare-and-swap operation, implemented by the CompareAndSwapT
functions, is the atomic equivalent of:
</p>
<pre>if *addr == old {
	*addr = new
	return true
}
return false
</pre>
<p>
The add operation, implemented by the AddT functions, is the atomic
equivalent of:
</p>
<pre>*addr += delta
return *addr
</pre>
<p>
The load and store operations, implemented by the LoadT and StoreT
functions, are the atomic equivalents of &#34;return *addr&#34; and
&#34;*addr = val&#34;.
</p>
<p>
In the terminology of [the Go memory model], if the effect of
an atomic operation A is observed by atomic operation B,
then A &ldquo;synchronizes before&rdquo; B.
Additionally, all the atomic operations executed in a program
behave as though executed in some sequentially consistent order.
This definition provides the same semantics as
C++&#39;s sequentially consistent atomics and Java&#39;s volatile variables.
</p>
<p>
[the Go memory model]: <a href="https://go.dev/ref/mem">https://go.dev/ref/mem</a>
</p>

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="index.html#AddInt32">func AddInt32(addr *int32, delta int32) (new int32)</a></dd>
			
				
				<dd><a href="index.html#AddInt64">func AddInt64(addr *int64, delta int64) (new int64)</a></dd>
			
				
				<dd><a href="index.html#AddUint32">func AddUint32(addr *uint32, delta uint32) (new uint32)</a></dd>
			
				
				<dd><a href="index.html#AddUint64">func AddUint64(addr *uint64, delta uint64) (new uint64)</a></dd>
			
				
				<dd><a href="index.html#AddUintptr">func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</a></dd>
			
				
				<dd><a href="index.html#AndInt32">func AndInt32(addr *int32, mask int32) (old int32)</a></dd>
			
				
				<dd><a href="index.html#AndInt64">func AndInt64(addr *int64, mask int64) (old int64)</a></dd>
			
				
				<dd><a href="index.html#AndUint32">func AndUint32(addr *uint32, mask uint32) (old uint32)</a></dd>
			
				
				<dd><a href="index.html#AndUint64">func AndUint64(addr *uint64, mask uint64) (old uint64)</a></dd>
			
				
				<dd><a href="index.html#AndUintptr">func AndUintptr(addr *uintptr, mask uintptr) (old uintptr)</a></dd>
			
				
				<dd><a href="index.html#CompareAndSwapInt32">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</a></dd>
			
				
				<dd><a href="index.html#CompareAndSwapInt64">func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)</a></dd>
			
				
				<dd><a href="index.html#CompareAndSwapPointer">func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</a></dd>
			
				
				<dd><a href="index.html#CompareAndSwapUint32">func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)</a></dd>
			
				
				<dd><a href="index.html#CompareAndSwapUint64">func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)</a></dd>
			
				
				<dd><a href="index.html#CompareAndSwapUintptr">func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)</a></dd>
			
				
				<dd><a href="index.html#LoadInt32">func LoadInt32(addr *int32) (val int32)</a></dd>
			
				
				<dd><a href="index.html#LoadInt64">func LoadInt64(addr *int64) (val int64)</a></dd>
			
				
				<dd><a href="index.html#LoadPointer">func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</a></dd>
			
				
				<dd><a href="index.html#LoadUint32">func LoadUint32(addr *uint32) (val uint32)</a></dd>
			
				
				<dd><a href="index.html#LoadUint64">func LoadUint64(addr *uint64) (val uint64)</a></dd>
			
				
				<dd><a href="index.html#LoadUintptr">func LoadUintptr(addr *uintptr) (val uintptr)</a></dd>
			
				
				<dd><a href="index.html#OrInt32">func OrInt32(addr *int32, mask int32) (old int32)</a></dd>
			
				
				<dd><a href="index.html#OrInt64">func OrInt64(addr *int64, mask int64) (old int64)</a></dd>
			
				
				<dd><a href="index.html#OrUint32">func OrUint32(addr *uint32, mask uint32) (old uint32)</a></dd>
			
				
				<dd><a href="index.html#OrUint64">func OrUint64(addr *uint64, mask uint64) (old uint64)</a></dd>
			
				
				<dd><a href="index.html#OrUintptr">func OrUintptr(addr *uintptr, mask uintptr) (old uintptr)</a></dd>
			
				
				<dd><a href="index.html#StoreInt32">func StoreInt32(addr *int32, val int32)</a></dd>
			
				
				<dd><a href="index.html#StoreInt64">func StoreInt64(addr *int64, val int64)</a></dd>
			
				
				<dd><a href="index.html#StorePointer">func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</a></dd>
			
				
				<dd><a href="index.html#StoreUint32">func StoreUint32(addr *uint32, val uint32)</a></dd>
			
				
				<dd><a href="index.html#StoreUint64">func StoreUint64(addr *uint64, val uint64)</a></dd>
			
				
				<dd><a href="index.html#StoreUintptr">func StoreUintptr(addr *uintptr, val uintptr)</a></dd>
			
				
				<dd><a href="index.html#SwapInt32">func SwapInt32(addr *int32, new int32) (old int32)</a></dd>
			
				
				<dd><a href="index.html#SwapInt64">func SwapInt64(addr *int64, new int64) (old int64)</a></dd>
			
				
				<dd><a href="index.html#SwapPointer">func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</a></dd>
			
				
				<dd><a href="index.html#SwapUint32">func SwapUint32(addr *uint32, new uint32) (old uint32)</a></dd>
			
				
				<dd><a href="index.html#SwapUint64">func SwapUint64(addr *uint64, new uint64) (old uint64)</a></dd>
			
				
				<dd><a href="index.html#SwapUintptr">func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)</a></dd>
			
			
				
				<dd><a href="index.html#Bool">type Bool</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Bool.CompareAndSwap">func (x *Bool) CompareAndSwap(old, new bool) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Bool.Load">func (x *Bool) Load() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Bool.Store">func (x *Bool) Store(val bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Bool.Swap">func (x *Bool) Swap(new bool) (old bool)</a></dd>
				
			
				
				<dd><a href="index.html#Int32">type Int32</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int32.Add">func (x *Int32) Add(delta int32) (new int32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int32.And">func (x *Int32) And(mask int32) (old int32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int32.CompareAndSwap">func (x *Int32) CompareAndSwap(old, new int32) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int32.Load">func (x *Int32) Load() int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int32.Or">func (x *Int32) Or(mask int32) (old int32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int32.Store">func (x *Int32) Store(val int32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int32.Swap">func (x *Int32) Swap(new int32) (old int32)</a></dd>
				
			
				
				<dd><a href="index.html#Int64">type Int64</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int64.Add">func (x *Int64) Add(delta int64) (new int64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int64.And">func (x *Int64) And(mask int64) (old int64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int64.CompareAndSwap">func (x *Int64) CompareAndSwap(old, new int64) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int64.Load">func (x *Int64) Load() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int64.Or">func (x *Int64) Or(mask int64) (old int64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int64.Store">func (x *Int64) Store(val int64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int64.Swap">func (x *Int64) Swap(new int64) (old int64)</a></dd>
				
			
				
				<dd><a href="index.html#Pointer">type Pointer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Pointer.CompareAndSwap">func (x *Pointer[T]) CompareAndSwap(old, new *T) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Pointer.Load">func (x *Pointer[T]) Load() *T</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Pointer.Store">func (x *Pointer[T]) Store(val *T)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Pointer.Swap">func (x *Pointer[T]) Swap(new *T) (old *T)</a></dd>
				
			
				
				<dd><a href="index.html#Uint32">type Uint32</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint32.Add">func (x *Uint32) Add(delta uint32) (new uint32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint32.And">func (x *Uint32) And(mask uint32) (old uint32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint32.CompareAndSwap">func (x *Uint32) CompareAndSwap(old, new uint32) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint32.Load">func (x *Uint32) Load() uint32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint32.Or">func (x *Uint32) Or(mask uint32) (old uint32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint32.Store">func (x *Uint32) Store(val uint32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint32.Swap">func (x *Uint32) Swap(new uint32) (old uint32)</a></dd>
				
			
				
				<dd><a href="index.html#Uint64">type Uint64</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint64.Add">func (x *Uint64) Add(delta uint64) (new uint64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint64.And">func (x *Uint64) And(mask uint64) (old uint64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint64.CompareAndSwap">func (x *Uint64) CompareAndSwap(old, new uint64) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint64.Load">func (x *Uint64) Load() uint64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint64.Or">func (x *Uint64) Or(mask uint64) (old uint64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint64.Store">func (x *Uint64) Store(val uint64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint64.Swap">func (x *Uint64) Swap(new uint64) (old uint64)</a></dd>
				
			
				
				<dd><a href="index.html#Uintptr">type Uintptr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uintptr.Add">func (x *Uintptr) Add(delta uintptr) (new uintptr)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uintptr.And">func (x *Uintptr) And(mask uintptr) (old uintptr)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uintptr.CompareAndSwap">func (x *Uintptr) CompareAndSwap(old, new uintptr) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uintptr.Load">func (x *Uintptr) Load() uintptr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uintptr.Or">func (x *Uintptr) Or(mask uintptr) (old uintptr)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uintptr.Store">func (x *Uintptr) Store(val uintptr)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uintptr.Swap">func (x *Uintptr) Swap(new uintptr) (old uintptr)</a></dd>
				
			
				
				<dd><a href="index.html#Value">type Value</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Value.CompareAndSwap">func (v *Value) CompareAndSwap(old, new any) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Value.Load">func (v *Value) Load() (val any)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Value.Store">func (v *Value) Store(val any)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Value.Swap">func (v *Value) Swap(new any) (old any)</a></dd>
				
			
			
				
				<dd><a href="index.html#pkg-note-BUG">Bugs</a></dd>
				
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="index.html#example_Value_config">Value (Config)</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Value_readMostly">Value (ReadMostly)</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:8080/src/sync/atomic/doc.go">doc.go</a>
			
				<a href="http://localhost:8080/src/sync/atomic/type.go">type.go</a>
			
				<a href="http://localhost:8080/src/sync/atomic/value.go">value.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
		
			
			
			<h2 id="AddInt32">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=5627:5678#L110">AddInt32</a>
				<a class="permalink" href="index.html#AddInt32">&#xb6;</a>
				
				
			</h2>
			<pre>func AddInt32(addr *<a href="../../builtin/index.html#int32">int32</a>, delta <a href="../../builtin/index.html#int32">int32</a>) (new <a href="../../builtin/index.html#int32">int32</a>)</pre>
			<p>
AddInt32 atomically adds delta to *addr and returns the new value.
Consider using the more ergonomic and less error-prone [Int32.Add] instead.
</p>

			
			

		
			
			
			<h2 id="AddInt64">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=6262:6313#L121">AddInt64</a>
				<a class="permalink" href="index.html#AddInt64">&#xb6;</a>
				
				
			</h2>
			<pre>func AddInt64(addr *<a href="../../builtin/index.html#int64">int64</a>, delta <a href="../../builtin/index.html#int64">int64</a>) (new <a href="../../builtin/index.html#int64">int64</a>)</pre>
			<p>
AddInt64 atomically adds delta to *addr and returns the new value.
Consider using the more ergonomic and less error-prone [Int64.Add] instead
(particularly if you target 32-bit platforms; see the bugs section).
</p>

			
			

		
			
			
			<h2 id="AddUint32">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=5985:6040#L116">AddUint32</a>
				<a class="permalink" href="index.html#AddUint32">&#xb6;</a>
				
				
			</h2>
			<pre>func AddUint32(addr *<a href="../../builtin/index.html#uint32">uint32</a>, delta <a href="../../builtin/index.html#uint32">uint32</a>) (new <a href="../../builtin/index.html#uint32">uint32</a>)</pre>
			<p>
AddUint32 atomically adds delta to *addr and returns the new value.
To subtract a signed positive constant value c from x, do AddUint32(&amp;x, ^uint32(c-1)).
In particular, to decrement x, do AddUint32(&amp;x, ^uint32(0)).
Consider using the more ergonomic and less error-prone [Uint32.Add] instead.
</p>

			
			

		
			
			
			<h2 id="AddUint64">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=6691:6746#L128">AddUint64</a>
				<a class="permalink" href="index.html#AddUint64">&#xb6;</a>
				
				
			</h2>
			<pre>func AddUint64(addr *<a href="../../builtin/index.html#uint64">uint64</a>, delta <a href="../../builtin/index.html#uint64">uint64</a>) (new <a href="../../builtin/index.html#uint64">uint64</a>)</pre>
			<p>
AddUint64 atomically adds delta to *addr and returns the new value.
To subtract a signed positive constant value c from x, do AddUint64(&amp;x, ^uint64(c-1)).
In particular, to decrement x, do AddUint64(&amp;x, ^uint64(0)).
Consider using the more ergonomic and less error-prone [Uint64.Add] instead
(particularly if you target 32-bit platforms; see the bugs section).
</p>

			
			

		
			
			
			<h2 id="AddUintptr">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=6901:6960#L132">AddUintptr</a>
				<a class="permalink" href="index.html#AddUintptr">&#xb6;</a>
				
				
			</h2>
			<pre>func AddUintptr(addr *<a href="../../builtin/index.html#uintptr">uintptr</a>, delta <a href="../../builtin/index.html#uintptr">uintptr</a>) (new <a href="../../builtin/index.html#uintptr">uintptr</a>)</pre>
			<p>
AddUintptr atomically adds delta to *addr and returns the new value.
Consider using the more ergonomic and less error-prone [Uintptr.Add] instead.
</p>

			
			

		
			
			
			<h2 id="AndInt32">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=7171:7221#L137">AndInt32</a>
				<a class="permalink" href="index.html#AndInt32">&#xb6;</a>
				
				
			</h2>
			<pre>func AndInt32(addr *<a href="../../builtin/index.html#int32">int32</a>, mask <a href="../../builtin/index.html#int32">int32</a>) (old <a href="../../builtin/index.html#int32">int32</a>)</pre>
			<p>
AndInt32 atomically performs a bitwise AND operation on *addr using the bitmask provided as mask
and returns the old value.
Consider using the more ergonomic and less error-prone [Int32.And] instead.
</p>

			
			

		
			
			
			<h2 id="AndInt64">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=7699:7749#L147">AndInt64</a>
				<a class="permalink" href="index.html#AndInt64">&#xb6;</a>
				
				
			</h2>
			<pre>func AndInt64(addr *<a href="../../builtin/index.html#int64">int64</a>, mask <a href="../../builtin/index.html#int64">int64</a>) (old <a href="../../builtin/index.html#int64">int64</a>)</pre>
			<p>
AndInt64 atomically performs a bitwise AND operation on *addr using the bitmask provided as mask
and returns the old value.
Consider using the more ergonomic and less error-prone [Int64.And] instead.
</p>

			
			

		
			
			
			<h2 id="AndUint32">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=7434:7488#L142">AndUint32</a>
				<a class="permalink" href="index.html#AndUint32">&#xb6;</a>
				
				
			</h2>
			<pre>func AndUint32(addr *<a href="../../builtin/index.html#uint32">uint32</a>, mask <a href="../../builtin/index.html#uint32">uint32</a>) (old <a href="../../builtin/index.html#uint32">uint32</a>)</pre>
			<p>
AndUint32 atomically performs a bitwise AND operation on *addr using the bitmask provided as mask
and returns the old value.
Consider using the more ergonomic and less error-prone [Uint32.And] instead.
</p>

			
			

		
			
			
			<h2 id="AndUint64">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=7956:8010#L152">AndUint64</a>
				<a class="permalink" href="index.html#AndUint64">&#xb6;</a>
				
				
			</h2>
			<pre>func AndUint64(addr *<a href="../../builtin/index.html#uint64">uint64</a>, mask <a href="../../builtin/index.html#uint64">uint64</a>) (old <a href="../../builtin/index.html#uint64">uint64</a>)</pre>
			<p>
AndUint64 atomically performs a bitwise AND operation on *addr using the bitmask provided as mask
and returns the old.
Consider using the more ergonomic and less error-prone [Uint64.And] instead.
</p>

			
			

		
			
			
			<h2 id="AndUintptr">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=8225:8283#L157">AndUintptr</a>
				<a class="permalink" href="index.html#AndUintptr">&#xb6;</a>
				
				
			</h2>
			<pre>func AndUintptr(addr *<a href="../../builtin/index.html#uintptr">uintptr</a>, mask <a href="../../builtin/index.html#uintptr">uintptr</a>) (old <a href="../../builtin/index.html#uintptr">uintptr</a>)</pre>
			<p>
AndUintptr atomically performs a bitwise AND operation on *addr using the bitmask provided as mask
and returns the old value.
Consider using the more ergonomic and less error-prone [Uintptr.And] instead.
</p>

			
			

		
			
			
			<h2 id="CompareAndSwapInt32">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=3998:4066#L84">CompareAndSwapInt32</a>
				<a class="permalink" href="index.html#CompareAndSwapInt32">&#xb6;</a>
				
				
			</h2>
			<pre>func CompareAndSwapInt32(addr *<a href="../../builtin/index.html#int32">int32</a>, old, new <a href="../../builtin/index.html#int32">int32</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
			<p>
CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.
Consider using the more ergonomic and less error-prone [Int32.CompareAndSwap] instead.
</p>

			
			

		
			
			
			<h2 id="CompareAndSwapInt64">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=4312:4380#L89">CompareAndSwapInt64</a>
				<a class="permalink" href="index.html#CompareAndSwapInt64">&#xb6;</a>
				
				
			</h2>
			<pre>func CompareAndSwapInt64(addr *<a href="../../builtin/index.html#int64">int64</a>, old, new <a href="../../builtin/index.html#int64">int64</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
			<p>
CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value.
Consider using the more ergonomic and less error-prone [Int64.CompareAndSwap] instead
(particularly if you target 32-bit platforms; see the bugs section).
</p>

			
			

		
			
			
			<h2 id="CompareAndSwapPointer">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=5388:5476#L106">CompareAndSwapPointer</a>
				<a class="permalink" href="index.html#CompareAndSwapPointer">&#xb6;</a>
				
				
			</h2>
			<pre>func CompareAndSwapPointer(addr *<a href="../../unsafe/index.html">unsafe</a>.<a href="../../unsafe/index.html#Pointer">Pointer</a>, old, new <a href="../../unsafe/index.html">unsafe</a>.<a href="../../unsafe/index.html#Pointer">Pointer</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
			<p>
CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value.
Consider using the more ergonomic and less error-prone [Pointer.CompareAndSwap] instead.
</p>

			
			

		
			
			
			<h2 id="CompareAndSwapUint32">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=4557:4628#L93">CompareAndSwapUint32</a>
				<a class="permalink" href="index.html#CompareAndSwapUint32">&#xb6;</a>
				
				
			</h2>
			<pre>func CompareAndSwapUint32(addr *<a href="../../builtin/index.html#uint32">uint32</a>, old, new <a href="../../builtin/index.html#uint32">uint32</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
			<p>
CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value.
Consider using the more ergonomic and less error-prone [Uint32.CompareAndSwap] instead.
</p>

			
			

		
			
			
			<h2 id="CompareAndSwapUint64">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=4876:4947#L98">CompareAndSwapUint64</a>
				<a class="permalink" href="index.html#CompareAndSwapUint64">&#xb6;</a>
				
				
			</h2>
			<pre>func CompareAndSwapUint64(addr *<a href="../../builtin/index.html#uint64">uint64</a>, old, new <a href="../../builtin/index.html#uint64">uint64</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
			<p>
CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value.
Consider using the more ergonomic and less error-prone [Uint64.CompareAndSwap] instead
(particularly if you target 32-bit platforms; see the bugs section).
</p>

			
			

		
			
			
			<h2 id="CompareAndSwapUintptr">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=5127:5201#L102">CompareAndSwapUintptr</a>
				<a class="permalink" href="index.html#CompareAndSwapUintptr">&#xb6;</a>
				
				
			</h2>
			<pre>func CompareAndSwapUintptr(addr *<a href="../../builtin/index.html#uintptr">uintptr</a>, old, new <a href="../../builtin/index.html#uintptr">uintptr</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
			<p>
CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value.
Consider using the more ergonomic and less error-prone [Uintptr.CompareAndSwap] instead.
</p>

			
			

		
			
			
			<h2 id="LoadInt32">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=9711:9750#L186">LoadInt32</a>
				<a class="permalink" href="index.html#LoadInt32">&#xb6;</a>
				
				
			</h2>
			<pre>func LoadInt32(addr *<a href="../../builtin/index.html#int32">int32</a>) (val <a href="../../builtin/index.html#int32">int32</a>)</pre>
			<p>
LoadInt32 atomically loads *addr.
Consider using the more ergonomic and less error-prone [Int32.Load] instead.
</p>

			
			

		
			
			
			<h2 id="LoadInt64">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=9940:9979#L191">LoadInt64</a>
				<a class="permalink" href="index.html#LoadInt64">&#xb6;</a>
				
				
			</h2>
			<pre>func LoadInt64(addr *<a href="../../builtin/index.html#int64">int64</a>) (val <a href="../../builtin/index.html#int64">int64</a>)</pre>
			<p>
LoadInt64 atomically loads *addr.
Consider using the more ergonomic and less error-prone [Int64.Load] instead
(particularly if you target 32-bit platforms; see the bugs section).
</p>

			
			

		
			
			
			<h2 id="LoadPointer">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=10667:10726#L208">LoadPointer</a>
				<a class="permalink" href="index.html#LoadPointer">&#xb6;</a>
				
				
			</h2>
			<pre>func LoadPointer(addr *<a href="../../unsafe/index.html">unsafe</a>.<a href="../../unsafe/index.html#Pointer">Pointer</a>) (val <a href="../../unsafe/index.html">unsafe</a>.<a href="../../unsafe/index.html#Pointer">Pointer</a>)</pre>
			<p>
LoadPointer atomically loads *addr.
Consider using the more ergonomic and less error-prone [Pointer.Load] instead.
</p>

			
			

		
			
			
			<h2 id="LoadUint32">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=10100:10142#L195">LoadUint32</a>
				<a class="permalink" href="index.html#LoadUint32">&#xb6;</a>
				
				
			</h2>
			<pre>func LoadUint32(addr *<a href="../../builtin/index.html#uint32">uint32</a>) (val <a href="../../builtin/index.html#uint32">uint32</a>)</pre>
			<p>
LoadUint32 atomically loads *addr.
Consider using the more ergonomic and less error-prone [Uint32.Load] instead.
</p>

			
			

		
			
			
			<h2 id="LoadUint64">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=10334:10376#L200">LoadUint64</a>
				<a class="permalink" href="index.html#LoadUint64">&#xb6;</a>
				
				
			</h2>
			<pre>func LoadUint64(addr *<a href="../../builtin/index.html#uint64">uint64</a>) (val <a href="../../builtin/index.html#uint64">uint64</a>)</pre>
			<p>
LoadUint64 atomically loads *addr.
Consider using the more ergonomic and less error-prone [Uint64.Load] instead
(particularly if you target 32-bit platforms; see the bugs section).
</p>

			
			

		
			
			
			<h2 id="LoadUintptr">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=10499:10544#L204">LoadUintptr</a>
				<a class="permalink" href="index.html#LoadUintptr">&#xb6;</a>
				
				
			</h2>
			<pre>func LoadUintptr(addr *<a href="../../builtin/index.html#uintptr">uintptr</a>) (val <a href="../../builtin/index.html#uintptr">uintptr</a>)</pre>
			<p>
LoadUintptr atomically loads *addr.
Consider using the more ergonomic and less error-prone [Uintptr.Load] instead.
</p>

			
			

		
			
			
			<h2 id="OrInt32">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=8491:8540#L162">OrInt32</a>
				<a class="permalink" href="index.html#OrInt32">&#xb6;</a>
				
				
			</h2>
			<pre>func OrInt32(addr *<a href="../../builtin/index.html#int32">int32</a>, mask <a href="../../builtin/index.html#int32">int32</a>) (old <a href="../../builtin/index.html#int32">int32</a>)</pre>
			<p>
OrInt32 atomically performs a bitwise OR operation on *addr using the bitmask provided as mask
and returns the old value.
Consider using the more ergonomic and less error-prone [Int32.Or] instead.
</p>

			
			

		
			
			
			<h2 id="OrInt64">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=9011:9060#L172">OrInt64</a>
				<a class="permalink" href="index.html#OrInt64">&#xb6;</a>
				
				
			</h2>
			<pre>func OrInt64(addr *<a href="../../builtin/index.html#int64">int64</a>, mask <a href="../../builtin/index.html#int64">int64</a>) (old <a href="../../builtin/index.html#int64">int64</a>)</pre>
			<p>
OrInt64 atomically performs a bitwise OR operation on *addr using the bitmask provided as mask
and returns the old value.
Consider using the more ergonomic and less error-prone [Int64.Or] instead.
</p>

			
			

		
			
			
			<h2 id="OrUint32">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=8750:8803#L167">OrUint32</a>
				<a class="permalink" href="index.html#OrUint32">&#xb6;</a>
				
				
			</h2>
			<pre>func OrUint32(addr *<a href="../../builtin/index.html#uint32">uint32</a>, mask <a href="../../builtin/index.html#uint32">uint32</a>) (old <a href="../../builtin/index.html#uint32">uint32</a>)</pre>
			<p>
OrUint32 atomically performs a bitwise OR operation on *addr using the bitmask provided as mask
and returns the old value.
Consider using the more ergonomic and less error-prone [Uint32.Or] instead.
</p>

			
			

		
			
			
			<h2 id="OrUint64">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=9270:9323#L177">OrUint64</a>
				<a class="permalink" href="index.html#OrUint64">&#xb6;</a>
				
				
			</h2>
			<pre>func OrUint64(addr *<a href="../../builtin/index.html#uint64">uint64</a>, mask <a href="../../builtin/index.html#uint64">uint64</a>) (old <a href="../../builtin/index.html#uint64">uint64</a>)</pre>
			<p>
OrUint64 atomically performs a bitwise OR operation on *addr using the bitmask provided as mask
and returns the old value.
Consider using the more ergonomic and less error-prone [Uint64.Or] instead.
</p>

			
			

		
			
			
			<h2 id="OrUintptr">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=9535:9592#L182">OrUintptr</a>
				<a class="permalink" href="index.html#OrUintptr">&#xb6;</a>
				
				
			</h2>
			<pre>func OrUintptr(addr *<a href="../../builtin/index.html#uintptr">uintptr</a>, mask <a href="../../builtin/index.html#uintptr">uintptr</a>) (old <a href="../../builtin/index.html#uintptr">uintptr</a>)</pre>
			<p>
OrUintptr atomically performs a bitwise OR operation on *addr using the bitmask provided as mask
and returns the old value.
Consider using the more ergonomic and less error-prone [Uintptr.Or] instead.
</p>

			
			

		
			
			
			<h2 id="StoreInt32">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=10857:10896#L212">StoreInt32</a>
				<a class="permalink" href="index.html#StoreInt32">&#xb6;</a>
				
				
			</h2>
			<pre>func StoreInt32(addr *<a href="../../builtin/index.html#int32">int32</a>, val <a href="../../builtin/index.html#int32">int32</a>)</pre>
			<p>
StoreInt32 atomically stores val into *addr.
Consider using the more ergonomic and less error-prone [Int32.Store] instead.
</p>

			
			

		
			
			
			<h2 id="StoreInt64">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=11098:11137#L217">StoreInt64</a>
				<a class="permalink" href="index.html#StoreInt64">&#xb6;</a>
				
				
			</h2>
			<pre>func StoreInt64(addr *<a href="../../builtin/index.html#int64">int64</a>, val <a href="../../builtin/index.html#int64">int64</a>)</pre>
			<p>
StoreInt64 atomically stores val into *addr.
Consider using the more ergonomic and less error-prone [Int64.Store] instead
(particularly if you target 32-bit platforms; see the bugs section).
</p>

			
			

		
			
			
			<h2 id="StorePointer">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=11873:11932#L234">StorePointer</a>
				<a class="permalink" href="index.html#StorePointer">&#xb6;</a>
				
				
			</h2>
			<pre>func StorePointer(addr *<a href="../../unsafe/index.html">unsafe</a>.<a href="../../unsafe/index.html#Pointer">Pointer</a>, val <a href="../../unsafe/index.html">unsafe</a>.<a href="../../unsafe/index.html#Pointer">Pointer</a>)</pre>
			<p>
StorePointer atomically stores val into *addr.
Consider using the more ergonomic and less error-prone [Pointer.Store] instead.
</p>

			
			

		
			
			
			<h2 id="StoreUint32">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=11270:11312#L221">StoreUint32</a>
				<a class="permalink" href="index.html#StoreUint32">&#xb6;</a>
				
				
			</h2>
			<pre>func StoreUint32(addr *<a href="../../builtin/index.html#uint32">uint32</a>, val <a href="../../builtin/index.html#uint32">uint32</a>)</pre>
			<p>
StoreUint32 atomically stores val into *addr.
Consider using the more ergonomic and less error-prone [Uint32.Store] instead.
</p>

			
			

		
			
			
			<h2 id="StoreUint64">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=11516:11558#L226">StoreUint64</a>
				<a class="permalink" href="index.html#StoreUint64">&#xb6;</a>
				
				
			</h2>
			<pre>func StoreUint64(addr *<a href="../../builtin/index.html#uint64">uint64</a>, val <a href="../../builtin/index.html#uint64">uint64</a>)</pre>
			<p>
StoreUint64 atomically stores val into *addr.
Consider using the more ergonomic and less error-prone [Uint64.Store] instead
(particularly if you target 32-bit platforms; see the bugs section).
</p>

			
			

		
			
			
			<h2 id="StoreUintptr">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=11693:11738#L230">StoreUintptr</a>
				<a class="permalink" href="index.html#StoreUintptr">&#xb6;</a>
				
				
			</h2>
			<pre>func StoreUintptr(addr *<a href="../../builtin/index.html#uintptr">uintptr</a>, val <a href="../../builtin/index.html#uintptr">uintptr</a>)</pre>
			<p>
StoreUintptr atomically stores val into *addr.
Consider using the more ergonomic and less error-prone [Uintptr.Store] instead.
</p>

			
			

		
			
			
			<h2 id="SwapInt32">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=2494:2544#L58">SwapInt32</a>
				<a class="permalink" href="index.html#SwapInt32">&#xb6;</a>
				
				
			</h2>
			<pre>func SwapInt32(addr *<a href="../../builtin/index.html#int32">int32</a>, new <a href="../../builtin/index.html#int32">int32</a>) (old <a href="../../builtin/index.html#int32">int32</a>)</pre>
			<p>
SwapInt32 atomically stores new into *addr and returns the previous *addr value.
Consider using the more ergonomic and less error-prone [Int32.Swap] instead.
</p>

			
			

		
			
			
			<h2 id="SwapInt64">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=2781:2831#L63">SwapInt64</a>
				<a class="permalink" href="index.html#SwapInt64">&#xb6;</a>
				
				
			</h2>
			<pre>func SwapInt64(addr *<a href="../../builtin/index.html#int64">int64</a>, new <a href="../../builtin/index.html#int64">int64</a>) (old <a href="../../builtin/index.html#int64">int64</a>)</pre>
			<p>
SwapInt64 atomically stores new into *addr and returns the previous *addr value.
Consider using the more ergonomic and less error-prone [Int64.Swap] instead
(particularly if you target 32-bit platforms; see the bugs section).
</p>

			
			

		
			
			
			<h2 id="SwapPointer">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=3744:3823#L80">SwapPointer</a>
				<a class="permalink" href="index.html#SwapPointer">&#xb6;</a>
				
				
			</h2>
			<pre>func SwapPointer(addr *<a href="../../unsafe/index.html">unsafe</a>.<a href="../../unsafe/index.html#Pointer">Pointer</a>, new <a href="../../unsafe/index.html">unsafe</a>.<a href="../../unsafe/index.html#Pointer">Pointer</a>) (old <a href="../../unsafe/index.html">unsafe</a>.<a href="../../unsafe/index.html#Pointer">Pointer</a>)</pre>
			<p>
SwapPointer atomically stores new into *addr and returns the previous *addr value.
Consider using the more ergonomic and less error-prone [Pointer.Swap] instead.
</p>

			
			

		
			
			
			<h2 id="SwapUint32">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=2999:3053#L67">SwapUint32</a>
				<a class="permalink" href="index.html#SwapUint32">&#xb6;</a>
				
				
			</h2>
			<pre>func SwapUint32(addr *<a href="../../builtin/index.html#uint32">uint32</a>, new <a href="../../builtin/index.html#uint32">uint32</a>) (old <a href="../../builtin/index.html#uint32">uint32</a>)</pre>
			<p>
SwapUint32 atomically stores new into *addr and returns the previous *addr value.
Consider using the more ergonomic and less error-prone [Uint32.Swap] instead.
</p>

			
			

		
			
			
			<h2 id="SwapUint64">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=3292:3346#L72">SwapUint64</a>
				<a class="permalink" href="index.html#SwapUint64">&#xb6;</a>
				
				
			</h2>
			<pre>func SwapUint64(addr *<a href="../../builtin/index.html#uint64">uint64</a>, new <a href="../../builtin/index.html#uint64">uint64</a>) (old <a href="../../builtin/index.html#uint64">uint64</a>)</pre>
			<p>
SwapUint64 atomically stores new into *addr and returns the previous *addr value.
Consider using the more ergonomic and less error-prone [Uint64.Swap] instead
(particularly if you target 32-bit platforms; see the bugs section).
</p>

			
			

		
			
			
			<h2 id="SwapUintptr">func <a href="http://localhost:8080/src/sync/atomic/doc.go?s=3516:3574#L76">SwapUintptr</a>
				<a class="permalink" href="index.html#SwapUintptr">&#xb6;</a>
				
				
			</h2>
			<pre>func SwapUintptr(addr *<a href="../../builtin/index.html#uintptr">uintptr</a>, new <a href="../../builtin/index.html#uintptr">uintptr</a>) (old <a href="../../builtin/index.html#uintptr">uintptr</a>)</pre>
			<p>
SwapUintptr atomically stores new into *addr and returns the previous *addr value.
Consider using the more ergonomic and less error-prone [Uintptr.Swap] instead.
</p>

			
			

		
		
			
			
			<h2 id="Bool">type <a href="http://localhost:8080/src/sync/atomic/type.go?s=259:299#L1">Bool</a>
				<a class="permalink" href="index.html#Bool">&#xb6;</a>
				
				
			</h2>
			<p>
A Bool is an atomic boolean value.
The zero value is false.
</p>

			<pre>type Bool struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Bool.CompareAndSwap">func (*Bool) <a href="http://localhost:8080/src/sync/atomic/type.go?s=762:821#L16">CompareAndSwap</a>
					<a class="permalink" href="index.html#Bool.CompareAndSwap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Bool">Bool</a>) CompareAndSwap(old, new <a href="../../builtin/index.html#bool">bool</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>
CompareAndSwap executes the compare-and-swap operation for the boolean value x.
</p>

				
				
				
			
				
				<h3 id="Bool.Load">func (*Bool) <a href="http://localhost:8080/src/sync/atomic/type.go?s=361:387#L7">Load</a>
					<a class="permalink" href="index.html#Bool.Load">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Bool">Bool</a>) Load() <a href="../../builtin/index.html#bool">bool</a></pre>
				<p>
Load atomically loads and returns the value stored in x.
</p>

				
				
				
			
				
				<h3 id="Bool.Store">func (*Bool) <a href="http://localhost:8080/src/sync/atomic/type.go?s=461:491#L10">Store</a>
					<a class="permalink" href="index.html#Bool.Store">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Bool">Bool</a>) Store(val <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>
Store atomically stores val into x.
</p>

				
				
				
			
				
				<h3 id="Bool.Swap">func (*Bool) <a href="http://localhost:8080/src/sync/atomic/type.go?s=594:634#L13">Swap</a>
					<a class="permalink" href="index.html#Bool.Swap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Bool">Bool</a>) Swap(new <a href="../../builtin/index.html#bool">bool</a>) (old <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>
Swap atomically stores new into x and returns the previous value.
</p>

				
				
				
			
		
			
			
			<h2 id="Int32">type <a href="http://localhost:8080/src/sync/atomic/type.go?s=2164:2204#L58">Int32</a>
				<a class="permalink" href="index.html#Int32">&#xb6;</a>
				
				
			</h2>
			<p>
An Int32 is an atomic int32. The zero value is zero.
</p>

			<pre>type Int32 struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Int32.Add">func (*Int32) <a href="http://localhost:8080/src/sync/atomic/type.go?s=2805:2849#L78">Add</a>
					<a class="permalink" href="index.html#Int32.Add">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int32">Int32</a>) Add(delta <a href="../../builtin/index.html#int32">int32</a>) (new <a href="../../builtin/index.html#int32">int32</a>)</pre>
				<p>
Add atomically adds delta to x and returns the new value.
</p>

				
				
				
			
				
				<h3 id="Int32.And">func (*Int32) <a href="http://localhost:8080/src/sync/atomic/type.go?s=3005:3048#L82">And</a>
					<a class="permalink" href="index.html#Int32.And">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int32">Int32</a>) And(mask <a href="../../builtin/index.html#int32">int32</a>) (old <a href="../../builtin/index.html#int32">int32</a>)</pre>
				<p>
And atomically performs a bitwise AND operation on x using the bitmask
provided as mask and returns the old value.
</p>

				
				
				
			
				
				<h3 id="Int32.CompareAndSwap">func (*Int32) <a href="http://localhost:8080/src/sync/atomic/type.go?s=2633:2694#L73">CompareAndSwap</a>
					<a class="permalink" href="index.html#Int32.CompareAndSwap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int32">Int32</a>) CompareAndSwap(old, new <a href="../../builtin/index.html#int32">int32</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>
CompareAndSwap executes the compare-and-swap operation for x.
</p>

				
				
				
			
				
				<h3 id="Int32.Load">func (*Int32) <a href="http://localhost:8080/src/sync/atomic/type.go?s=2266:2294#L64">Load</a>
					<a class="permalink" href="index.html#Int32.Load">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int32">Int32</a>) Load() <a href="../../builtin/index.html#int32">int32</a></pre>
				<p>
Load atomically loads and returns the value stored in x.
</p>

				
				
				
			
				
				<h3 id="Int32.Or">func (*Int32) <a href="http://localhost:8080/src/sync/atomic/type.go?s=3201:3243#L86">Or</a>
					<a class="permalink" href="index.html#Int32.Or">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int32">Int32</a>) Or(mask <a href="../../builtin/index.html#int32">int32</a>) (old <a href="../../builtin/index.html#int32">int32</a>)</pre>
				<p>
Or atomically performs a bitwise OR operation on x using the bitmask
provided as mask and returns the old value.
</p>

				
				
				
			
				
				<h3 id="Int32.Store">func (*Int32) <a href="http://localhost:8080/src/sync/atomic/type.go?s=2362:2394#L67">Store</a>
					<a class="permalink" href="index.html#Int32.Store">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int32">Int32</a>) Store(val <a href="../../builtin/index.html#int32">int32</a>)</pre>
				<p>
Store atomically stores val into x.
</p>

				
				
				
			
				
				<h3 id="Int32.Swap">func (*Int32) <a href="http://localhost:8080/src/sync/atomic/type.go?s=2491:2534#L70">Swap</a>
					<a class="permalink" href="index.html#Int32.Swap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int32">Int32</a>) Swap(new <a href="../../builtin/index.html#int32">int32</a>) (old <a href="../../builtin/index.html#int32">int32</a>)</pre>
				<p>
Swap atomically stores new into x and returns the previous value.
</p>

				
				
				
			
		
			
			
			<h2 id="Int64">type <a href="http://localhost:8080/src/sync/atomic/type.go?s=3332:3383#L89">Int64</a>
				<a class="permalink" href="index.html#Int64">&#xb6;</a>
				
				
			</h2>
			<p>
An Int64 is an atomic int64. The zero value is zero.
</p>

			<pre>type Int64 struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Int64.Add">func (*Int64) <a href="http://localhost:8080/src/sync/atomic/type.go?s=3984:4028#L110">Add</a>
					<a class="permalink" href="index.html#Int64.Add">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int64">Int64</a>) Add(delta <a href="../../builtin/index.html#int64">int64</a>) (new <a href="../../builtin/index.html#int64">int64</a>)</pre>
				<p>
Add atomically adds delta to x and returns the new value.
</p>

				
				
				
			
				
				<h3 id="Int64.And">func (*Int64) <a href="http://localhost:8080/src/sync/atomic/type.go?s=4184:4227#L114">And</a>
					<a class="permalink" href="index.html#Int64.And">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int64">Int64</a>) And(mask <a href="../../builtin/index.html#int64">int64</a>) (old <a href="../../builtin/index.html#int64">int64</a>)</pre>
				<p>
And atomically performs a bitwise AND operation on x using the bitmask
provided as mask and returns the old value.
</p>

				
				
				
			
				
				<h3 id="Int64.CompareAndSwap">func (*Int64) <a href="http://localhost:8080/src/sync/atomic/type.go?s=3812:3873#L105">CompareAndSwap</a>
					<a class="permalink" href="index.html#Int64.CompareAndSwap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int64">Int64</a>) CompareAndSwap(old, new <a href="../../builtin/index.html#int64">int64</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>
CompareAndSwap executes the compare-and-swap operation for x.
</p>

				
				
				
			
				
				<h3 id="Int64.Load">func (*Int64) <a href="http://localhost:8080/src/sync/atomic/type.go?s=3445:3473#L96">Load</a>
					<a class="permalink" href="index.html#Int64.Load">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int64">Int64</a>) Load() <a href="../../builtin/index.html#int64">int64</a></pre>
				<p>
Load atomically loads and returns the value stored in x.
</p>

				
				
				
			
				
				<h3 id="Int64.Or">func (*Int64) <a href="http://localhost:8080/src/sync/atomic/type.go?s=4380:4422#L118">Or</a>
					<a class="permalink" href="index.html#Int64.Or">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int64">Int64</a>) Or(mask <a href="../../builtin/index.html#int64">int64</a>) (old <a href="../../builtin/index.html#int64">int64</a>)</pre>
				<p>
Or atomically performs a bitwise OR operation on x using the bitmask
provided as mask and returns the old value.
</p>

				
				
				
			
				
				<h3 id="Int64.Store">func (*Int64) <a href="http://localhost:8080/src/sync/atomic/type.go?s=3541:3573#L99">Store</a>
					<a class="permalink" href="index.html#Int64.Store">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int64">Int64</a>) Store(val <a href="../../builtin/index.html#int64">int64</a>)</pre>
				<p>
Store atomically stores val into x.
</p>

				
				
				
			
				
				<h3 id="Int64.Swap">func (*Int64) <a href="http://localhost:8080/src/sync/atomic/type.go?s=3670:3713#L102">Swap</a>
					<a class="permalink" href="index.html#Int64.Swap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int64">Int64</a>) Swap(new <a href="../../builtin/index.html#int64">int64</a>) (old <a href="../../builtin/index.html#int64">int64</a>)</pre>
				<p>
Swap atomically stores new into x and returns the previous value.
</p>

				
				
				
			
		
			
			
			<h2 id="Pointer">type <a href="http://localhost:8080/src/sync/atomic/type.go?s=1223:1479#L33">Pointer</a>
				<a class="permalink" href="index.html#Pointer">&#xb6;</a>
				
				
			</h2>
			<p>
A Pointer is an atomic pointer of type *T. The zero value is a nil *T.
</p>

			<pre>type Pointer[T <a href="../../builtin/index.html#any">any</a>] struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Pointer.CompareAndSwap">func (*Pointer[T]) <a href="http://localhost:8080/src/sync/atomic/type.go?s=1961:2024#L53">CompareAndSwap</a>
					<a class="permalink" href="index.html#Pointer.CompareAndSwap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Pointer">Pointer</a>[<a href="index.html#T">T</a>]) CompareAndSwap(old, new *<a href="index.html#T">T</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>
CompareAndSwap executes the compare-and-swap operation for x.
</p>

				
				
				
			
				
				<h3 id="Pointer.Load">func (*Pointer[T]) <a href="http://localhost:8080/src/sync/atomic/type.go?s=1541:1571#L44">Load</a>
					<a class="permalink" href="index.html#Pointer.Load">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Pointer">Pointer</a>[<a href="index.html#T">T</a>]) Load() *<a href="index.html#T">T</a></pre>
				<p>
Load atomically loads and returns the value stored in x.
</p>

				
				
				
			
				
				<h3 id="Pointer.Store">func (*Pointer[T]) <a href="http://localhost:8080/src/sync/atomic/type.go?s=1647:1681#L47">Store</a>
					<a class="permalink" href="index.html#Pointer.Store">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Pointer">Pointer</a>[<a href="index.html#T">T</a>]) Store(val *<a href="index.html#T">T</a>)</pre>
				<p>
Store atomically stores val into x.
</p>

				
				
				
			
				
				<h3 id="Pointer.Swap">func (*Pointer[T]) <a href="http://localhost:8080/src/sync/atomic/type.go?s=1796:1838#L50">Swap</a>
					<a class="permalink" href="index.html#Pointer.Swap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Pointer">Pointer</a>[<a href="index.html#T">T</a>]) Swap(new *<a href="index.html#T">T</a>) (old *<a href="index.html#T">T</a>)</pre>
				<p>
Swap atomically stores new into x and returns the previous value.
</p>

				
				
				
			
		
			
			
			<h2 id="Uint32">type <a href="http://localhost:8080/src/sync/atomic/type.go?s=4512:4554#L121">Uint32</a>
				<a class="permalink" href="index.html#Uint32">&#xb6;</a>
				
				
			</h2>
			<p>
A Uint32 is an atomic uint32. The zero value is zero.
</p>

			<pre>type Uint32 struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Uint32.Add">func (*Uint32) <a href="http://localhost:8080/src/sync/atomic/type.go?s=5168:5215#L141">Add</a>
					<a class="permalink" href="index.html#Uint32.Add">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint32">Uint32</a>) Add(delta <a href="../../builtin/index.html#uint32">uint32</a>) (new <a href="../../builtin/index.html#uint32">uint32</a>)</pre>
				<p>
Add atomically adds delta to x and returns the new value.
</p>

				
				
				
			
				
				<h3 id="Uint32.And">func (*Uint32) <a href="http://localhost:8080/src/sync/atomic/type.go?s=5372:5418#L145">And</a>
					<a class="permalink" href="index.html#Uint32.And">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint32">Uint32</a>) And(mask <a href="../../builtin/index.html#uint32">uint32</a>) (old <a href="../../builtin/index.html#uint32">uint32</a>)</pre>
				<p>
And atomically performs a bitwise AND operation on x using the bitmask
provided as mask and returns the old value.
</p>

				
				
				
			
				
				<h3 id="Uint32.CompareAndSwap">func (*Uint32) <a href="http://localhost:8080/src/sync/atomic/type.go?s=4993:5056#L136">CompareAndSwap</a>
					<a class="permalink" href="index.html#Uint32.CompareAndSwap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint32">Uint32</a>) CompareAndSwap(old, new <a href="../../builtin/index.html#uint32">uint32</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>
CompareAndSwap executes the compare-and-swap operation for x.
</p>

				
				
				
			
				
				<h3 id="Uint32.Load">func (*Uint32) <a href="http://localhost:8080/src/sync/atomic/type.go?s=4616:4646#L127">Load</a>
					<a class="permalink" href="index.html#Uint32.Load">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint32">Uint32</a>) Load() <a href="../../builtin/index.html#uint32">uint32</a></pre>
				<p>
Load atomically loads and returns the value stored in x.
</p>

				
				
				
			
				
				<h3 id="Uint32.Or">func (*Uint32) <a href="http://localhost:8080/src/sync/atomic/type.go?s=5572:5617#L149">Or</a>
					<a class="permalink" href="index.html#Uint32.Or">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint32">Uint32</a>) Or(mask <a href="../../builtin/index.html#uint32">uint32</a>) (old <a href="../../builtin/index.html#uint32">uint32</a>)</pre>
				<p>
Or atomically performs a bitwise OR operation on x using the bitmask
provided as mask and returns the old value.
</p>

				
				
				
			
				
				<h3 id="Uint32.Store">func (*Uint32) <a href="http://localhost:8080/src/sync/atomic/type.go?s=4715:4749#L130">Store</a>
					<a class="permalink" href="index.html#Uint32.Store">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint32">Uint32</a>) Store(val <a href="../../builtin/index.html#uint32">uint32</a>)</pre>
				<p>
Store atomically stores val into x.
</p>

				
				
				
			
				
				<h3 id="Uint32.Swap">func (*Uint32) <a href="http://localhost:8080/src/sync/atomic/type.go?s=4847:4893#L133">Swap</a>
					<a class="permalink" href="index.html#Uint32.Swap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint32">Uint32</a>) Swap(new <a href="../../builtin/index.html#uint32">uint32</a>) (old <a href="../../builtin/index.html#uint32">uint32</a>)</pre>
				<p>
Swap atomically stores new into x and returns the previous value.
</p>

				
				
				
			
		
			
			
			<h2 id="Uint64">type <a href="http://localhost:8080/src/sync/atomic/type.go?s=5708:5761#L152">Uint64</a>
				<a class="permalink" href="index.html#Uint64">&#xb6;</a>
				
				
			</h2>
			<p>
A Uint64 is an atomic uint64. The zero value is zero.
</p>

			<pre>type Uint64 struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Uint64.Add">func (*Uint64) <a href="http://localhost:8080/src/sync/atomic/type.go?s=6375:6422#L173">Add</a>
					<a class="permalink" href="index.html#Uint64.Add">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint64">Uint64</a>) Add(delta <a href="../../builtin/index.html#uint64">uint64</a>) (new <a href="../../builtin/index.html#uint64">uint64</a>)</pre>
				<p>
Add atomically adds delta to x and returns the new value.
</p>

				
				
				
			
				
				<h3 id="Uint64.And">func (*Uint64) <a href="http://localhost:8080/src/sync/atomic/type.go?s=6579:6625#L177">And</a>
					<a class="permalink" href="index.html#Uint64.And">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint64">Uint64</a>) And(mask <a href="../../builtin/index.html#uint64">uint64</a>) (old <a href="../../builtin/index.html#uint64">uint64</a>)</pre>
				<p>
And atomically performs a bitwise AND operation on x using the bitmask
provided as mask and returns the old value.
</p>

				
				
				
			
				
				<h3 id="Uint64.CompareAndSwap">func (*Uint64) <a href="http://localhost:8080/src/sync/atomic/type.go?s=6200:6263#L168">CompareAndSwap</a>
					<a class="permalink" href="index.html#Uint64.CompareAndSwap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint64">Uint64</a>) CompareAndSwap(old, new <a href="../../builtin/index.html#uint64">uint64</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>
CompareAndSwap executes the compare-and-swap operation for x.
</p>

				
				
				
			
				
				<h3 id="Uint64.Load">func (*Uint64) <a href="http://localhost:8080/src/sync/atomic/type.go?s=5823:5853#L159">Load</a>
					<a class="permalink" href="index.html#Uint64.Load">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint64">Uint64</a>) Load() <a href="../../builtin/index.html#uint64">uint64</a></pre>
				<p>
Load atomically loads and returns the value stored in x.
</p>

				
				
				
			
				
				<h3 id="Uint64.Or">func (*Uint64) <a href="http://localhost:8080/src/sync/atomic/type.go?s=6779:6824#L181">Or</a>
					<a class="permalink" href="index.html#Uint64.Or">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint64">Uint64</a>) Or(mask <a href="../../builtin/index.html#uint64">uint64</a>) (old <a href="../../builtin/index.html#uint64">uint64</a>)</pre>
				<p>
Or atomically performs a bitwise OR operation on x using the bitmask
provided as mask and returns the old value.
</p>

				
				
				
			
				
				<h3 id="Uint64.Store">func (*Uint64) <a href="http://localhost:8080/src/sync/atomic/type.go?s=5922:5956#L162">Store</a>
					<a class="permalink" href="index.html#Uint64.Store">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint64">Uint64</a>) Store(val <a href="../../builtin/index.html#uint64">uint64</a>)</pre>
				<p>
Store atomically stores val into x.
</p>

				
				
				
			
				
				<h3 id="Uint64.Swap">func (*Uint64) <a href="http://localhost:8080/src/sync/atomic/type.go?s=6054:6100#L165">Swap</a>
					<a class="permalink" href="index.html#Uint64.Swap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint64">Uint64</a>) Swap(new <a href="../../builtin/index.html#uint64">uint64</a>) (old <a href="../../builtin/index.html#uint64">uint64</a>)</pre>
				<p>
Swap atomically stores new into x and returns the previous value.
</p>

				
				
				
			
		
			
			
			<h2 id="Uintptr">type <a href="http://localhost:8080/src/sync/atomic/type.go?s=6917:6961#L184">Uintptr</a>
				<a class="permalink" href="index.html#Uintptr">&#xb6;</a>
				
				
			</h2>
			<p>
A Uintptr is an atomic uintptr. The zero value is zero.
</p>

			<pre>type Uintptr struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Uintptr.Add">func (*Uintptr) <a href="http://localhost:8080/src/sync/atomic/type.go?s=7588:7638#L204">Add</a>
					<a class="permalink" href="index.html#Uintptr.Add">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uintptr">Uintptr</a>) Add(delta <a href="../../builtin/index.html#uintptr">uintptr</a>) (new <a href="../../builtin/index.html#uintptr">uintptr</a>)</pre>
				<p>
Add atomically adds delta to x and returns the new value.
</p>

				
				
				
			
				
				<h3 id="Uintptr.And">func (*Uintptr) <a href="http://localhost:8080/src/sync/atomic/type.go?s=7796:7845#L208">And</a>
					<a class="permalink" href="index.html#Uintptr.And">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uintptr">Uintptr</a>) And(mask <a href="../../builtin/index.html#uintptr">uintptr</a>) (old <a href="../../builtin/index.html#uintptr">uintptr</a>)</pre>
				<p>
And atomically performs a bitwise AND operation on x using the bitmask
provided as mask and returns the old value.
</p>

				
				
				
			
				
				<h3 id="Uintptr.CompareAndSwap">func (*Uintptr) <a href="http://localhost:8080/src/sync/atomic/type.go?s=7410:7475#L199">CompareAndSwap</a>
					<a class="permalink" href="index.html#Uintptr.CompareAndSwap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uintptr">Uintptr</a>) CompareAndSwap(old, new <a href="../../builtin/index.html#uintptr">uintptr</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>
CompareAndSwap executes the compare-and-swap operation for x.
</p>

				
				
				
			
				
				<h3 id="Uintptr.Load">func (*Uintptr) <a href="http://localhost:8080/src/sync/atomic/type.go?s=7023:7055#L190">Load</a>
					<a class="permalink" href="index.html#Uintptr.Load">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uintptr">Uintptr</a>) Load() <a href="../../builtin/index.html#uintptr">uintptr</a></pre>
				<p>
Load atomically loads and returns the value stored in x.
</p>

				
				
				
			
				
				<h3 id="Uintptr.Or">func (*Uintptr) <a href="http://localhost:8080/src/sync/atomic/type.go?s=8027:8075#L212">Or</a>
					<a class="permalink" href="index.html#Uintptr.Or">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uintptr">Uintptr</a>) Or(mask <a href="../../builtin/index.html#uintptr">uintptr</a>) (old <a href="../../builtin/index.html#uintptr">uintptr</a>)</pre>
				<p>
Or atomically performs a bitwise OR operation on x using the bitmask
provided as mask and returns the updated value after the OR operation.
</p>

				
				
				
			
				
				<h3 id="Uintptr.Store">func (*Uintptr) <a href="http://localhost:8080/src/sync/atomic/type.go?s=7125:7161#L193">Store</a>
					<a class="permalink" href="index.html#Uintptr.Store">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uintptr">Uintptr</a>) Store(val <a href="../../builtin/index.html#uintptr">uintptr</a>)</pre>
				<p>
Store atomically stores val into x.
</p>

				
				
				
			
				
				<h3 id="Uintptr.Swap">func (*Uintptr) <a href="http://localhost:8080/src/sync/atomic/type.go?s=7260:7309#L196">Swap</a>
					<a class="permalink" href="index.html#Uintptr.Swap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uintptr">Uintptr</a>) Swap(new <a href="../../builtin/index.html#uintptr">uintptr</a>) (old <a href="../../builtin/index.html#uintptr">uintptr</a>)</pre>
				<p>
Swap atomically stores new into x and returns the previous value.
</p>

				
				
				
			
		
			
			
			<h2 id="Value">type <a href="http://localhost:8080/src/sync/atomic/value.go?s=452:480#L6">Value</a>
				<a class="permalink" href="index.html#Value">&#xb6;</a>
				
				
			</h2>
			<p>
A Value provides an atomic load and store of a consistently typed value.
The zero value for a Value returns nil from [Value.Load].
Once [Value.Store] has been called, a Value must not be copied.
</p>
<p>
A Value must not be copied after first use.
</p>

			<pre>type Value struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Value_config" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Config)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Config)</span></p>
		<p>The following example shows how to use Value for periodic program config updates
and propagation of the changes to worker goroutines.
</p>
		
		
			<p>Code:</p>
			<pre class="code">
var config atomic.Value <span class="comment">// holds current server configuration</span>
<span class="comment">// Create initial config value and store into config.</span>
config.Store(loadConfig())
go func() {
    <span class="comment">// Reload config every 10 seconds</span>
    <span class="comment">// and update config value with the new version.</span>
    for {
        time.Sleep(10 * time.Second)
        config.Store(loadConfig())
    }
}()
<span class="comment">// Create worker goroutines that handle incoming requests</span>
<span class="comment">// using the latest config value.</span>
for i := 0; i &lt; 10; i++ {
    go func() {
        for r := range requests() {
            c := config.Load()
            <span class="comment">// Handle request r using config c.</span>
            _, _ = r, c
        }
    }()
}
</pre>
			
		
	</div>
</div>
<div id="example_Value_readMostly" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (ReadMostly)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (ReadMostly)</span></p>
		<p>The following example shows how to maintain a scalable frequently read,
but infrequently updated data structure using copy-on-write idiom.
</p>
		
		
			<p>Code:</p>
			<pre class="code">
type Map map[string]string
var m atomic.Value
m.Store(make(Map))
var mu sync.Mutex <span class="comment">// used only by writers</span>
<span class="comment">// read function can be used to read the data without further synchronization</span>
read := func(key string) (val string) {
    m1 := m.Load().(Map)
    return m1[key]
}
<span class="comment">// insert function can be used to update the data without further synchronization</span>
insert := func(key, val string) {
    mu.Lock() <span class="comment">// synchronize with other potential writers</span>
    defer mu.Unlock()
    m1 := m.Load().(Map) <span class="comment">// load current value of the data structure</span>
    m2 := make(Map)      <span class="comment">// create a new value</span>
    for k, v := range m1 {
        m2[k] = v <span class="comment">// copy all data from the current object to the new one</span>
    }
    m2[key] = val <span class="comment">// do the update that we need</span>
    m.Store(m2)   <span class="comment">// atomically replace the current object with the new one</span>
    <span class="comment">// At this point all new readers start working with the new version.</span>
    <span class="comment">// The old version will be garbage collected once the existing readers</span>
    <span class="comment">// (if any) are done with it.</span>
}
_, _ = read, insert
</pre>
			
		
	</div>
</div>

			
			

			

			
				
				<h3 id="Value.CompareAndSwap">func (*Value) <a href="http://localhost:8080/src/sync/atomic/value.go?s=4097:4156#L125">CompareAndSwap</a>
					<a class="permalink" href="index.html#Value.CompareAndSwap">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Value">Value</a>) CompareAndSwap(old, new <a href="../../builtin/index.html#any">any</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>
CompareAndSwap executes the compare-and-swap operation for the [Value].
</p>
<p>
All calls to CompareAndSwap for a given Value must use values of the same
concrete type. CompareAndSwap of an inconsistent type panics, as does
CompareAndSwap(old, nil).
</p>

				
				
				
			
				
				<h3 id="Value.Load">func (*Value) <a href="http://localhost:8080/src/sync/atomic/value.go?s=731:763#L18">Load</a>
					<a class="permalink" href="index.html#Value.Load">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Value">Value</a>) Load() (val <a href="../../builtin/index.html#any">any</a>)</pre>
				<p>
Load returns the value set by the most recent Store.
It returns nil if there has been no call to Store for this Value.
</p>

				
				
				
			
				
				<h3 id="Value.Store">func (*Value) <a href="http://localhost:8080/src/sync/atomic/value.go?s=1294:1324#L37">Store</a>
					<a class="permalink" href="index.html#Value.Store">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Value">Value</a>) Store(val <a href="../../builtin/index.html#any">any</a>)</pre>
				<p>
Store sets the value of the [Value] v to val.
All calls to Store for a given Value must use values of the same concrete type.
Store of an inconsistent type panics, as does Store(nil).
</p>

				
				
				
			
				
				<h3 id="Value.Swap">func (*Value) <a href="http://localhost:8080/src/sync/atomic/value.go?s=2620:2659#L80">Swap</a>
					<a class="permalink" href="index.html#Value.Swap">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Value">Value</a>) Swap(new <a href="../../builtin/index.html#any">any</a>) (old <a href="../../builtin/index.html#any">any</a>)</pre>
				<p>
Swap stores new into Value and returns the previous value. It returns nil if
the Value is empty.
</p>
<p>
All calls to Swap for a given Value must use values of the same concrete
type. Swap of an inconsistent type panics, as does Swap(nil).
</p>

				
				
				
			
		
	

	
		
			<h2 id="pkg-note-BUG">Bugs</h2>
			<ul style="list-style: none; padding: 0;">
			
			<li><a href="http://localhost:8080/src/sync/atomic/doc.go?s=1679:2328#L45" style="float: left;">&#x261e;</a> <p>
On 386, the 64-bit functions use instructions unavailable before the Pentium MMX.
</p>
<p>
On non-Linux ARM, the 64-bit functions use instructions unavailable before the ARMv6k core.
</p>
<p>
On ARM, 386, and 32-bit MIPS, it is the caller&#39;s responsibility to arrange
for 64-bit alignment of 64-bit words accessed atomically via the primitive
atomic functions (types [Int64] and [Uint64] are automatically aligned).
The first word in an allocated struct, array, or slice; in a global
variable; or in a local variable (because the subject of all atomic operations
will escape to the heap) can be relied upon to be 64-bit aligned.
</p>
</li>
			
			</ul>
		
	







<div id="footer">
Build version go1.18.1.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:8080/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
